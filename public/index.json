[{"content":"Mastering SQLite Write-Ahead Logging (WAL): Use Cases, Best Practices, and Performance Benchmarks By default, SQLite uses a rollback journal mode to ensure atomicity, consistency, isolation, and durability (ACID) compliance. However, SQLite offers an alternative journaling mode called Write-Ahead Logging (WAL), which dramatically improves write performance and allows concurrent read and write operations.\nIn this post, we’ll dive deep into SQLite’s WAL mode, explaining how it works, when to use it, and its pros and cons. We’ll also explore benchmarks to see how it performs in different scenarios.\nWhat is SQLite Write-Ahead Logging (WAL)? The Write-Ahead Logging (WAL) mode in SQLite is an advanced journaling mechanism designed to improve performance and concurrency. In the default rollback journal mode, every write transaction locks the entire database, preventing concurrent reads and writes. WAL mode, on the other hand, writes changes to a separate WAL file, allowing reads and writes to occur simultaneously.\nIn WAL mode, the database works as follows:\nWrite Operations: Instead of writing directly to the main database file, changes are written to a separate WAL file.\nCheckpointing: When the WAL file grows beyond a certain size (default: 1,000 pages), SQLite merges changes from the WAL file back into the main database file in a process called \u0026ldquo;checkpointing.\u0026rdquo;\nRead Operations: Readers continue accessing the original database file while changes accumulate in the WAL file with minimal performance degradation compared to rollback mode.\nThis separation between readers and writers removes the bottleneck caused by exclusive locking, improving write performance and enabling more parallelism.\nHow to Enable WAL Mode in SQLite Activating WAL mode in SQLite is straightforward. You can enable it for a specific database by running the following SQL command:\nPRAGMA journal_mode = WAL; This command switches the database to WAL mode and creates a WAL file next to the main database file.\nYou can also check the current journaling mode with:\nPRAGMA journal_mode; To return to the default rollback journal mode, you can execute:\nPRAGMA journal_mode = DELETE; How Does WAL Mode Work? WAL mode fundamentally changes how SQLite manages database changes. Instead of writing directly to the database file, SQLite writes transactions into the WAL file. Let’s break down the key components of WAL mode:\nWAL File Temporary File: The WAL file stores changes until they are merged back into the main database file during a checkpoint.\nEfficient Writes: Since SQLite appends data to the WAL file, the write process is faster, avoiding costly file-locking operations that occur in rollback journal mode.\nCheckpointing Periodic Merging: During a checkpoint, SQLite applies the changes from the WAL file to the main database. Checkpointing can happen automatically or manually.\nOptimization: You can tune when checkpointing occurs (e.g., by adjusting the size of the WAL file) to balance performance and durability.\nReaders and Writers Concurrent Reads/Writes: Unlike rollback journal mode, where writes block reads, WAL mode allows multiple readers and one writer to work concurrently.\nRead Consistency: Readers in WAL mode access the unchanged database file, ensuring they get a consistent view of the data.\nWhen to Use WAL Mode WAL mode offers significant benefits in various scenarios, but it’s not suitable for every use case. Here are some ideal situations where WAL mode excels:\nHigh Write Performance WAL mode significantly improves write performance by avoiding the need to lock the entire database during each transaction. If your application is write-heavy, WAL mode is a good fit.\nConcurrent Reads and Writes In applications that require concurrent reads and writes, such as web applications or real-time data processing systems, WAL mode allows for more efficient concurrency without sacrificing read performance.\nEmbedded Systems and Mobile Applications Many mobile apps and embedded systems (e.g., IoT devices) use SQLite for data storage. These applications often benefit from WAL mode\u0026rsquo;s better concurrency and faster writes, especially when dealing with high-frequency data collection.\nLong-Running Reads In some applications, you may have long-running read transactions that block other operations. WAL mode allows long-running reads to continue without affecting write performance.\nWhen Not to Use WAL Mode While WAL mode offers great advantages, there are some scenarios where it may not be the best option:\nLimited Disk Space WAL mode requires additional disk space because it creates a separate WAL file for write transactions. If your application is running in an environment with limited disk space, such as embedded devices, this might be a concern. However, the WAL file is truncated periodically, so this is usually a manageable issue.\nSingle-Threaded Environments If your application is single-threaded and doesn’t require concurrent reads and writes, the performance improvements of WAL mode may be negligible. In such cases, the default rollback journal mode may suffice.\nExternal Storage (e.g., Network Filesystems) WAL mode might not work efficiently or not at all on network-mounted or cloud-based filesystems such as SMB or NFS. SQLite recommends caution when using WAL mode in environments where the file system might not provide fast access or low-latency storage.\nFrequent Checkpoints WAL mode works best when checkpoints are infrequent, allowing the WAL file to grow before merging changes into the main database. Applications that trigger frequent checkpoints (due to low checkpoint thresholds or explicit requests) may see diminished benefits, as frequent disk I/O will negate WAL’s write performance gains.\nPerformance Benchmarks The benchmarks were performed on a proxmox LXC with 1 CPU and 512MB of RAM, the figures are only meant to be judged relatively. I used the following go script to benchmark the database as go is a good choice for concurrent programs\npackage main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; _ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; ) const ( dbPath = \u0026#34;./test.db\u0026#34; numOperations = 1000 numWorkers = 10 ) func main() { // Test without WAL err := os.Remove(dbPath) if err != nil { fmt.Println(err) } fmt.Println(\u0026#34;Testing without WAL:\u0026#34;) runTest(false) if err != nil { fmt.Println(err) } // Test with WAL fmt.Println(\u0026#34;\\nTesting with WAL:\u0026#34;) runTest(true) } func runTest(useWAL bool) { db, err := sql.Open(\u0026#34;sqlite3\u0026#34;, dbPath) if err != nil { panic(err) } defer db.Close() if useWAL { _, err = db.Exec(\u0026#34;PRAGMA journal_mode=WAL;\u0026#34;) if err != nil { panic(err) } } // Create table _, err = db.Exec(`CREATE TABLE IF NOT EXISTS test_table (id INTEGER PRIMARY KEY, value TEXT);`) if err != nil { panic(err) } // Clear table _, err = db.Exec(`DELETE FROM test_table;`) if err != nil { panic(err) } start := time.Now() var wg sync.WaitGroup for i := 0; i \u0026lt; numWorkers; i++ { wg.Add(1) go func() { defer wg.Done() for j := 0; j \u0026lt; numOperations/numWorkers; j++ { if rand.Float32() \u0026lt; 0.5 { // Write operation _, err := db.Exec(\u0026#34;INSERT INTO test_table (value) VALUES (?)\u0026#34;, randomString(10)) if err != nil { fmt.Printf(\u0026#34;Write error: %v\\n\u0026#34;, err) } } else { // Read operation var value string q := \u0026#34;SELECT value FROM test_table ORDER BY RANDOM() LIMIT 1\u0026#34; err := db.QueryRow(q).Scan(\u0026amp;value) if err != nil \u0026amp;\u0026amp; err != sql.ErrNoRows { fmt.Printf(\u0026#34;Read error: %v\\n\u0026#34;, err) } } } }() } wg.Wait() duration := time.Since(start) fmt.Printf(\u0026#34;Time taken: %v\\n\u0026#34;, duration) fmt.Printf(\u0026#34;Operations per second: %.2f\\n\u0026#34;, float64(numOperations)/duration.Seconds()) } func randomString(length int) string { const charset = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#34; b := make([]byte, length) for i := range b { b[i] = charset[rand.Intn(len(charset))] } return string(b) } And here are the results:\nMode IO/s Time Elapsed Normal 56.54 17.68s WAL 17377.66 57.54ms Yeah I know\nConclusion: If you run a non fault tolerant app then continue using the default otherwise WAL is a no brainer for most people.\n","permalink":"http://localhost:1313/posts/sqlite-write-ahead-logging/","summary":"\u003ch1 id=\"mastering-sqlite-write-ahead-logging-wal-use-cases-best-practices-and-performance-benchmarks\"\u003eMastering SQLite Write-Ahead Logging (WAL): Use Cases, Best Practices, and Performance Benchmarks\u003c/h1\u003e\n\u003chr\u003e\n\u003cp\u003eBy default, SQLite uses a rollback journal mode to ensure atomicity, consistency, isolation, and durability (ACID) compliance. However, SQLite offers an alternative journaling mode called Write-Ahead Logging (WAL), which dramatically improves write performance and allows concurrent read and write operations.\u003c/p\u003e\n\u003cp\u003eIn this post, we’ll dive deep into SQLite’s WAL mode, explaining how it works, when to use it, and its pros and cons. We’ll also explore benchmarks to see how it performs in different scenarios.\u003c/p\u003e","title":"SQLite Write Ahead Logging"}]